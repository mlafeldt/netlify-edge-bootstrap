/* esm.sh - @netlify/cache@1.3.0/bootstrap */
import{NetlifyForwardedHost as R,ResourceHeaders as g,ResourceStatus as S,ResourceStore as _,UserAgent as E,__privateAdd as i,__privateGet as a,__privateSet as h}from"./dist/chunk-I5FZDZ6V.mjs";var y=new Set(["http:","https:"]),$=new Set(["cookie","content-encoding","content-length"]),l=Symbol("getInternalHeaders"),m=Symbol("serializeResourceHeaders"),d,n,u,c,C=class{constructor({base64Encode:e,getContext:t,name:r,userAgent:s}){i(this,d,void 0),i(this,n,void 0),i(this,u,void 0),i(this,c,void 0),h(this,d,e),h(this,n,t),h(this,u,r),h(this,c,s)}[l](e){let{host:t,token:r}=e,s={Authorization:`Bearer ${r}`,[_]:a(this,u)};return t&&(s[R]=t),a(this,c)&&(s[E]=a(this,c)),s}[m](e){let t={};return e.forEach((r,s)=>{$.has(s)||(s==="set-cookie"?(t[s]=t[s]||[],t[s].push(r)):t[s]=r.split(","))}),a(this,d).call(this,JSON.stringify(t))}async add(e){await this.put(new Request(e),await fetch(e))}async addAll(e){await Promise.allSettled(e.map(t=>this.add(t)))}async delete(e){let t=a(this,n).call(this),r=p(e);return await fetch(`${t.url}/${f(r)}`,{headers:this[l](t),method:"DELETE"}),!0}async keys(e){return[]}async match(e){try{let t=a(this,n).call(this),r=p(e),s=`${t.url}/${f(r)}`,v=await fetch(s,{headers:this[l](t),method:"GET"});return v.ok?v:void 0}catch{}}async matchAll(e,t){if(!e)return[];let r=await this.match(e);return r?[r]:[]}async put(e,t){if(!t.ok)throw new TypeError(`Cannot cache response with status ${t.status}.`);if(e instanceof Request&&e.method!=="GET")throw new TypeError(`Cannot cache response to ${e.method} request.`);if(t.status===206)throw new TypeError("Cannot cache response to a range request (206 Partial Content).");if(t.headers.get("vary")?.includes("*"))throw new TypeError("Cannot cache response with 'Vary: *' header.");let r=a(this,n).call(this),s=p(e);await fetch(`${r.url}/${f(s)}`,{body:t.body,headers:{...this[l](r),[g]:this[m](t.headers),[S]:t.status.toString()},duplex:"half",method:"POST"})}};d=new WeakMap;n=new WeakMap;u=new WeakMap;c=new WeakMap;var p=e=>{let t;if(e instanceof Request)t=new URL(e.url);else try{t=new URL(String(e))}catch{throw new TypeError(`${e} is not a valid URL.`)}if(!y.has(t.protocol))throw new TypeError(`Cannot cache response for URL with unsupported protocol (${t.protocol}). Supported protocols are ${[...y].join(", ")}.`);return t},f=e=>encodeURIComponent(e.toString()),w,o,L=class{constructor(e){i(this,w,void 0),i(this,o,void 0),h(this,w,e),h(this,o,new Map)}open(e){let t=a(this,o).get(e);return t||(t=new C({...a(this,w),name:e}),a(this,o).set(e,t)),Promise.resolve(t)}has(e){return Promise.resolve(a(this,o).has(e))}delete(e){return Promise.resolve(a(this,o).delete(e))}keys(){return Promise.resolve([...a(this,o).keys()])}async match(e,t){if(t?.cacheName)return a(this,o).get(t.cacheName)?.match(e);for(let r of a(this,o).values())if(await r.match(e)===void 0)return}};w=new WeakMap;o=new WeakMap;export{C as NetlifyCache,L as NetlifyCacheStorage};
//# sourceMappingURL=bootstrap.mjs.map